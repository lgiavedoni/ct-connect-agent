import { Request, Response } from 'express';
import { logger } from '../utils/logger.utils';
import { aiRunPrompt, aiRunPromptWithUserPrompt, model_flash_thinking, model_openai_gpt_4_o, model_openai_o3_mini } from '../client/ai.client';
import { Message } from 'ai';
import graphqlClient from '../client/graphqlExecution.client'; 
import CustomError from '../errors/custom.error';
import { generateGraphQLQuery } from '../tools/graphqlGeneration.tool';
import { executeGraphQLQuery } from '../tools/graphqlExecutor.tool';
import { cleanJson } from '../utils/json.utils';

// import {
//   HTTP_STATUS_RESOURCE_NOT_FOUND,
//   HTTP_STATUS_SUCCESS_ACCEPTED,
//   HTTP_STATUS_BAD_REQUEST,
//   HTTP_STATUS_SUCCESS_NO_CONTENT,
// } from '../constants/http.status.constants';

interface AgentRequest extends Request {
  body: {
    messages: Message[];
    [key: string]: unknown;
  };
}

const systemPrompt: string = `

    <goal>
    You are a helpful  assistant that manages a commercetools store.
    Your goal is to answer the user's request and ALWAYS try your best, even it takes multiple steps.
    IMPORTANT, do not tell me how you might or could do it. Just do it. The user wants the answer, not how you will get there.
    ***Try as much as possible avoid asking unneeded questions to the user. And make decisions based on the information provided by the user.***
    If you have a viable plan go and execute it, don't ask the user for confirmation.

    </goal>

    <tools>
    You are the main orchestator and will have at your disposal a number of tools to help you answer the user's request.
    ***IMPORTANT, use your tools to answer the user's request. Don't just do it yourself.***
    *** NEVER alucinate with data, or make up data.***
    </tools>

    <rules>
      NEVER try to execute a GraphQL query directly without first generating it with the generateGraphQLQuery tool.
      ***NEVER try to create a GraphQL query yourself - always use the generateGraphQLQuery tool.***
      If you need te generate and execute several GraphQL queries to solve the user's request that is ok.
      When there is an error with the GraphQL query, you will need to fix it by using the generateGraphQLQuery tool again and providing the error message.
      
      *** Critical, if you are going to update/delete/create an entity (basically any mutation) , you first have to ask user for confirmation providing useful information about the entity. And ALWAYS provide the entity's id and also include the hashtag (#CONFIRMATION_NEEDED) in the message.***

      ALLWAYS return a valid JSON object following the return_format below.
    </rules>
    <context>
      Today is ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}
    </context>


    <return_format>
      *****ALLWAYS Return a JSON object.*****
      The JSON should be in the following format (do NOT include anything else before or after the JSON object):
        {
          "answer": "The answer to the user's request. Give him the answer, not how you got it.
                    The user is a human, so your response should be in a natural language and easy to understand.
                    ALWAYS use markdown formatting to make your response more readable.",
          "graphql_queries": [ // This is an array of the queies generated by the generateGraphQLQuery tool. ONLY by the tool
                    {
                      "query": "The generated GraphQL query by the generateGraphQLQuery tool that where successfully executed",
                      "query_type": "The type of the query that was executed. Example: Read, Write",
                    }
                  ],
          "entities": [
                    {
                      "entity_type": "The type of the entity that has been involved in this oporation. Example: Products, Orders..",
                    }
                  ]
          
        }
        Even if you have not executed any GraphQL queries or something went wrong, you should return the return_format.
    </return_format>
`;
        // "graphql_query": [
        //         {
        //           "query": "The generated GraphQL query by the generateGraphQLQuery tool that where successfully executed",
        //           "query_type": "The type of the query that was executed. Example: Read, Write",
        //         }
        //       ],
        //       "entities": [
        //         {
        //           "entity_type": "The type of the entity that has been involved in this oporation. Example: Products, Orders..",
        //         }
        //       ]

export const angetHandler = async (request: AgentRequest, response: Response): Promise<Response> => {
  try {
    const { messages } = request.body;
    
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      logger.error('Missing or invalid messages array in request body.');
      throw new CustomError(
        400,
        'Bad request: messages array is required in request body',
        undefined
      );
    }else{
      logger.info(`Processing request, ${JSON.stringify(messages)}`);
    }

    logger.info(`Processing request with ${messages.length} messages`);
    const aiResponse = await aiRunPrompt(
      systemPrompt,
      messages,
      [generateGraphQLQuery, executeGraphQLQuery],
      model_openai_gpt_4_o
    );

    logger.info(`AI Response: ${aiResponse}`);
    
    // Clean the AI response to handle JSON wrapped in code blocks
    try {
      const cleanedResponse = cleanJson(aiResponse);
      return response.json(cleanedResponse);
    } catch (error) {
      // If parsing fails, return the original response
      logger.warn(`Failed to parse AI response as JSON: ${error instanceof Error ? error.message : String(error)}`);
      return response.json({
        answer: aiResponse
      });
    }
  } catch (err: unknown) {
    logger.error(err);
    console.log(err);
    if (err instanceof CustomError) {
      return response.status(Number(err.statusCode)).send(err);
    }
    if (typeof err === 'object' && err !== null && 'statusCode' in err) {
      return response.status(Number((err as { statusCode: number | string }).statusCode)).send(err);
    }
    return response.status(500).send(err);
  }
};
